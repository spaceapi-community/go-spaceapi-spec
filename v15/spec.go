// Code generated by schema-generate. DO NOT EDIT.

package spaceapistruct

import (
	"bytes"
	"encoding/json"
	"errors"
)

// AccountBalanceItems
type AccountBalanceItems struct {

	// An extra field that you can use to attach some additional information to this sensor instance.
	Description string `json:"description,omitempty"`

	// If you have more than one account you can use this field to specify where it is.
	Location string `json:"location,omitempty"`

	// Give your sensor instance a name.
	Name string `json:"name,omitempty"`

	// What's the currency? It should be formatted according to <a href="https://en.wikipedia.org/wiki/ISO_4217" target="_blank">ISO 4217</a> short-code format.
	Unit string `json:"unit"`

	// How much?
	Value float64 `json:"value"`
}

// AlphaItems
type AlphaItems struct {

	// The conversion from the <em>cpm</em> unit to another unit hardly depends on your tube type. See the description of the value field to see how to use the conversion factor. <strong>Note:</strong> only trust your manufacturer if it comes to the actual factor value. The internet seems <a rel="nofollow" href="http://sapporohibaku.wordpress.com/2011/10/15/conversion-factor/" target="_blank">full of wrong copy & pastes</a>, don't even trust your neighbour hackerspace. If in doubt ask the tube manufacturer.
	ConversionFactor float64 `json:"conversion_factor,omitempty"`

	// The dead time in µs. See the description of the value field to see how to use the dead time.
	DeadTime float64 `json:"dead_time,omitempty"`

	// An extra field that you can use to attach some additional information to this sensor instance.
	Description string `json:"description,omitempty"`

	// The location of your sensor such as <samp>Outside</samp>, <samp>Inside</samp>, <samp>Ceiling</samp>, <samp>Roof</samp> or <samp>Room 1</samp>.
	Location string `json:"location,omitempty"`

	// This field is an additional field to give your sensor a name. This can be useful if you have multiple sensors in the same location.
	Name string `json:"name,omitempty"`

	// Choose the appropriate unit for your radiation sensor instance.
	Unit string `json:"unit"`

	// Observed counts per minute (ocpm) or actual radiation value. If the value are the observed counts then the dead_time and conversion_factor fields must be defined as well. CPM formula: <div>cpm = ocpm ( 1 + 1 / (1 - ocpm x dead_time) )</div> Conversion formula: <div>µSv/h = cpm x conversion_factor</div>
	Value float64 `json:"value"`
}

// BarometerItems
type BarometerItems struct {

	// An extra field that you can use to attach some additional information to this sensor instance.
	Description string `json:"description,omitempty"`

	// The location of your sensor such as <samp>Outside</samp>, <samp>Inside</samp>, <samp>Ceiling</samp>, <samp>Roof</samp> or <samp>Room 1</samp>.
	Location string `json:"location"`

	// This field is an additional field to give your sensor a name. This can be useful if you have multiple sensors in the same location.
	Name string `json:"name,omitempty"`

	// The unit of pressure used by your sensor<br>Note: The <code>hPA</code> unit is deprecated and should not be used anymore. Use the correct <code>hPa</code> unit instead.
	Unit string `json:"unit"`

	// The sensor value
	Value float64 `json:"value"`
}

// BetaGammaItems
type BetaGammaItems struct {

	// The conversion from the <em>cpm</em> unit to another unit hardly depends on your tube type. See the description of the value field to see how to use the conversion factor. <strong>Note:</strong> only trust your manufacturer if it comes to the actual factor value. The internet seems <a rel="nofollow" href="http://sapporohibaku.wordpress.com/2011/10/15/conversion-factor/" target="_blank">full of wrong copy & pastes</a>, don't even trust your neighbour hackerspace. If in doubt ask the tube manufacturer.
	ConversionFactor float64 `json:"conversion_factor,omitempty"`

	// The dead time in µs. See the description of the value field to see how to use the dead time.
	DeadTime float64 `json:"dead_time,omitempty"`

	// An extra field that you can use to attach some additional information to this sensor instance.
	Description string `json:"description,omitempty"`

	// The location of your sensor such as <samp>Outside</samp>, <samp>Inside</samp>, <samp>Ceiling</samp>, <samp>Roof</samp> or <samp>Room 1</samp>.
	Location string `json:"location,omitempty"`

	// This field is an additional field to give your sensor a name. This can be useful if you have multiple sensors in the same location.
	Name string `json:"name,omitempty"`

	// Choose the appropriate unit for your radiation sensor instance.
	Unit string `json:"unit"`

	// Observed counts per minute (ocpm) or actual radiation value. If the value are the observed counts then the dead_time and conversion_factor fields must be defined as well. CPM formula: <div>cpm = ocpm ( 1 + 1 / (1 - ocpm x dead_time) )</div> Conversion formula: <div>µSv/h = cpm x conversion_factor</div>
	Value float64 `json:"value"`
}

// BetaItems
type BetaItems struct {

	// The conversion from the <em>cpm</em> unit to another unit hardly depends on your tube type. See the description of the value field to see how to use the conversion factor. <strong>Note:</strong> only trust your manufacturer if it comes to the actual factor value. The internet seems <a rel="nofollow" href="http://sapporohibaku.wordpress.com/2011/10/15/conversion-factor/" target="_blank">full of wrong copy & pastes</a>, don't even trust your neighbour hackerspace. If in doubt ask the tube manufacturer.
	ConversionFactor float64 `json:"conversion_factor,omitempty"`

	// The dead time in µs. See the description of the value field to see how to use the dead time.
	DeadTime float64 `json:"dead_time,omitempty"`

	// An extra field that you can use to attach some additional information to this sensor instance.
	Description string `json:"description,omitempty"`

	// The location of your sensor such as <samp>Outside</samp>, <samp>Inside</samp>, <samp>Ceiling</samp>, <samp>Roof</samp> or <samp>Room 1</samp>.
	Location string `json:"location,omitempty"`

	// This field is an additional field to give your sensor a name. This can be useful if you have multiple sensors in the same location.
	Name string `json:"name,omitempty"`

	// Choose the appropriate unit for your radiation sensor instance.
	Unit string `json:"unit"`

	// Observed counts per minute (ocpm) or actual radiation value. If the value are the observed counts then the dead_time and conversion_factor fields must be defined as well. CPM formula: <div>cpm = ocpm ( 1 + 1 / (1 - ocpm x dead_time) )</div> Conversion formula: <div>µSv/h = cpm x conversion_factor</div>
	Value float64 `json:"value"`
}

// BeverageSupplyItems
type BeverageSupplyItems struct {

	// An extra field that you can use to attach some additional information to this sensor instance.
	Description string `json:"description,omitempty"`

	// The location of your sensor such as <samp>Room 1</samp> or <samp>Room 2</samp> or <samp>Room 3</samp>, <samp>Roof</samp> or <samp>Room 1</samp>.
	Location string `json:"location,omitempty"`

	// This field is an additional field to give your sensor a name. This can be useful if you have multiple sensors in the same location.
	Name string `json:"name,omitempty"`

	// The unit, either <samp>btl</samp> for bottles or <samp>crt</samp> for crates.
	Unit string `json:"unit"`

	// The sensor value
	Value float64 `json:"value"`
}

// BitsPerSecond
type BitsPerSecond struct {

	// The maximum available throughput in bits/second, e.g. as sold by your ISP
	Maximum float64 `json:"maximum,omitempty"`

	// The measurement value, in bits/second
	Value float64 `json:"value"`
}

// Blog
type Blog struct {

	// Type of the feed, for example <samp>rss</samp>, <samp>atom</atom>, <samp>ical</samp>
	Type string `json:"type,omitempty"`

	// Feed URL
	Url string `json:"url"`
}

// Calendar
type Calendar struct {

	// Type of the feed, for example <samp>rss</samp>, <samp>atom</atom>, <samp>ical</samp>
	Type string `json:"type,omitempty"`

	// Feed URL
	Url string `json:"url"`
}

// Contact Contact information about your space. You must define at least one which is in the list of allowed values of the issue_report_channels field.
type Contact struct {

	// E-mail address for contacting your space. If this is a mailing list consider to use the contact/ml field.
	Email string `json:"email,omitempty"`

	// Facebook account URL.
	Facebook string `json:"facebook,omitempty"`

	// Foursquare ID, in the form <samp>4d8a9114d85f3704eab301dc</samp>.
	Foursquare string `json:"foursquare,omitempty"`

	// A URL to find information about the Space in the Gopherspace. Example: gopher://gopher.binary-kitchen.de
	Gopher string `json:"gopher,omitempty"`

	// Identi.ca or StatusNet account, in the form <samp>yourspace@example.org</samp>
	Identica string `json:"identica,omitempty"`

	// URL of the IRC channel, in the form <samp>irc://example.org/#channelname</samp>
	Irc string `json:"irc,omitempty"`

	// A separate email address for issue reports. This value can be Base64-encoded.
	IssueMail string `json:"issue_mail,omitempty"`

	// Persons who carry a key and are able to open the space upon request. One of the fields irc_nick, phone, email or twitter must be specified.
	Keymasters []*KeymastersItems `json:"keymasters,omitempty"`

	// Mastodon username: Example: @ordnung@chaos.social.
	Mastodon string `json:"mastodon,omitempty"`

	// Matrix channel/community for the Hackerspace. Example: <samp>#spaceroom:example.org</samp> or <samp>+spacecommunity:example.org</samp>
	Matrix string `json:"matrix,omitempty"`

	// The e-mail address of your mailing list. If you use Google Groups then the e-mail looks like <samp>your-group@googlegroups.com</samp>.
	Ml string `json:"ml,omitempty"`

	// URL to a Mumble server/channel, as specified in https://wiki.mumble.info/wiki/Mumble_URL . Example: <samp>mumble://mumble.example.org/spaceroom?version=1.2.0</samp>
	Mumble string `json:"mumble,omitempty"`

	// Phone number, including country code with a leading plus sign. Example: <samp>+1 800 555 4567</samp>
	Phone string `json:"phone,omitempty"`

	// URI for Voice-over-IP via SIP. Example: <samp>sip:yourspace@sip.example.org</samp>
	Sip string `json:"sip,omitempty"`

	// Twitter handle, with leading @
	Twitter string `json:"twitter,omitempty"`

	// A public Jabber/XMPP multi-user chatroom in the form <samp>chatroom@conference.example.net</samp>
	Xmpp string `json:"xmpp,omitempty"`
}

// Direction The wind direction in degrees.
type Direction struct {

	// The unit of the sensor value. You should always define the unit though if the sensor is a flag of a boolean type then you can of course omit it.
	Unit string `json:"unit"`

	// The sensor value
	Value float64 `json:"value"`
}

// DoorLockedItems
type DoorLockedItems struct {

	// An extra field that you can use to attach some additional information to this sensor instance.
	Description string `json:"description,omitempty"`

	// The location of your sensor such as <samp>front door</samp>, <samp>chill room</samp> or <samp>lab</samp>.
	Location string `json:"location"`

	// This field is an additional field to give your sensor a name. This can be useful if you have multiple sensors in the same location.
	Name string `json:"name,omitempty"`

	// The sensor value
	Value bool `json:"value"`
}

// Elevation Height above mean sea level.
type Elevation struct {

	// The unit of the sensor value. You should always define the unit though if the sensor is a flag of a boolean type then you can of course omit it.
	Unit string `json:"unit"`

	// The sensor value
	Value float64 `json:"value"`
}

// EventsItems
type EventsItems struct {

	// A custom text field to give more information about the event
	Extra string `json:"extra,omitempty"`

	// Name or other identity of the subject (e.g. <samp>J. Random Hacker</samp>, <samp>fridge</samp>, <samp>3D printer</samp>, …)
	Name string `json:"name"`

	// Unix timestamp when the event occurred
	Timestamp float64 `json:"timestamp"`

	// Action (e.g. <samp>check-in</samp>, <samp>check-out</samp>, <samp>finish-print</samp>, …). Define your own actions and use them consistently, canonical actions are not (yet) specified
	Type string `json:"type"`
}

// Feeds Feeds where users can get updates of your space
type Feeds struct {
	Blog     *Blog     `json:"blog,omitempty"`
	Calendar *Calendar `json:"calendar,omitempty"`
	Flickr   *Flickr   `json:"flickr,omitempty"`
	Wiki     *Wiki     `json:"wiki,omitempty"`
}

// Flickr
type Flickr struct {

	// Type of the feed, for example <samp>rss</samp>, <samp>atom</atom>, <samp>ical</samp>
	Type string `json:"type,omitempty"`

	// Feed URL
	Url string `json:"url"`
}

// GammaItems
type GammaItems struct {

	// The conversion from the <em>cpm</em> unit to another unit hardly depends on your tube type. See the description of the value field to see how to use the conversion factor. <strong>Note:</strong> only trust your manufacturer if it comes to the actual factor value. The internet seems <a rel="nofollow" href="http://sapporohibaku.wordpress.com/2011/10/15/conversion-factor/" target="_blank">full of wrong copy & pastes</a>, don't even trust your neighbour hackerspace. If in doubt ask the tube manufacturer.
	ConversionFactor float64 `json:"conversion_factor,omitempty"`

	// The dead time in µs. See the description of the value field to see how to use the dead time.
	DeadTime float64 `json:"dead_time,omitempty"`

	// An extra field that you can use to attach some additional information to this sensor instance.
	Description string `json:"description,omitempty"`

	// The location of your sensor such as <samp>Outside</samp>, <samp>Inside</samp>, <samp>Ceiling</samp>, <samp>Roof</samp> or <samp>Room 1</samp>.
	Location string `json:"location,omitempty"`

	// This field is an additional field to give your sensor a name. This can be useful if you have multiple sensors in the same location.
	Name string `json:"name,omitempty"`

	// Choose the appropriate unit for your radiation sensor instance.
	Unit string `json:"unit"`

	// Observed counts per minute (ocpm) or actual radiation value. If the value are the observed counts then the dead_time and conversion_factor fields must be defined as well. CPM formula: <div>cpm = ocpm ( 1 + 1 / (1 - ocpm x dead_time) )</div> Conversion formula: <div>µSv/h = cpm x conversion_factor</div>
	Value float64 `json:"value"`
}

// Gust
type Gust struct {

	// The unit of the sensor value. You should always define the unit though if the sensor is a flag of a boolean type then you can of course omit it.
	Unit string `json:"unit"`

	// The sensor value
	Value float64 `json:"value"`
}

// HumidityItems
type HumidityItems struct {

	// An extra field that you can use to attach some additional information to this sensor instance.
	Description string `json:"description,omitempty"`

	// The location of your sensor such as <samp>Outside</samp>, <samp>Inside</samp>, <samp>Ceiling</samp>, <samp>Roof</samp> or <samp>Room 1</samp>.
	Location string `json:"location"`

	// This field is an additional field to give your sensor a name. This can be useful if you have multiple sensors in the same location.
	Name string `json:"name,omitempty"`

	// The unit of the sensor value. You should always define the unit though if the sensor is a flag of a boolean type then you can of course omit it.
	Unit string `json:"unit"`

	// The sensor value
	Value float64 `json:"value"`
}

// Icon Icons that show the status graphically
type Icon struct {

	// The URL to your customized space logo showing a closed space
	Closed string `json:"closed"`

	// The URL to your customized space logo showing an open space
	Open string `json:"open"`
}

// KeymastersItems
type KeymastersItems struct {

	// Email address which can be base64 encoded.
	Email string `json:"email,omitempty"`

	// Contact the person with this nickname directly in irc if available. The irc channel to be used is defined in the contact/irc field.
	IrcNick string `json:"irc_nick,omitempty"`

	// Mastodon username. Example: @ordnung@chaos.social
	Mastodon string `json:"mastodon,omitempty"`

	// Matrix username. Example: <samp>@user:example.org</samp>
	Matrix string `json:"matrix,omitempty"`

	// Real name
	Name string `json:"name,omitempty"`

	// Example: <samp>['+1 800 555 4567','+1 800 555 4544']</samp>
	Phone string `json:"phone,omitempty"`

	// Twitter username with leading <samp>@</samp>.
	Twitter string `json:"twitter,omitempty"`

	// XMPP (Jabber) ID
	Xmpp string `json:"xmpp,omitempty"`
}

// LinksItems
type LinksItems struct {

	// An extra field for a more detailed description of the link.
	Description string `json:"description,omitempty"`

	// The link name.
	Name string `json:"name"`

	// The URL.
	Url string `json:"url"`
}

// Location Position data such as a postal address or geographic coordinates
type Location struct {

	// The postal address of your space (street, block, housenumber, zip code, city, whatever you usually need in your country, and the country itself).<br>Examples: <ul><li>Netzladen e.V., Breite Straße 74, 53111 Bonn, Germany</li></ul>
	Address string `json:"address,omitempty"`

	// Latitude of your space location, in degree with decimal places. Use positive values for locations north of the equator, negative values for locations south of equator.
	Lat float64 `json:"lat"`

	// Longitude of your space location, in degree with decimal places. Use positive values for locations east of Greenwich, and negative values for locations west of Greenwich.
	Lon float64 `json:"lon"`

	// The timezone the space is located in. It should be formatted according to the <a target="_blank" href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">TZ database location names</a>.
	Timezone string `json:"timezone,omitempty"`
}

// MachinesItems
type MachinesItems struct {

	// The machine's MAC address of the format <samp>D3:3A:DB:EE:FF:00</samp>.
	Mac string `json:"mac"`

	// The machine name.
	Name string `json:"name,omitempty"`
}

// MembershipPlansItems
type MembershipPlansItems struct {

	// How often is the membership billed? If you select other, please specify in the description what your billing interval is.
	BillingInterval string `json:"billing_interval"`

	// What's the currency? It should be formatted according to <a href="https://en.wikipedia.org/wiki/ISO_4217" target="_blank">ISO 4217</a> short-code format.
	Currency string `json:"currency"`

	// A free form string.
	Description string `json:"description,omitempty"`

	// The name of the membership plan. For example Student Membership, Normal Membership etc.
	Name string `json:"name"`

	// How much does this plan cost?
	Value float64 `json:"value"`
}

// NetworkConnectionsItems
type NetworkConnectionsItems struct {

	// An extra field that you can use to attach some additional information to this sensor instance.
	Description string `json:"description,omitempty"`

	// The location of your sensor such as <samp>Outside</samp>, <samp>Inside</samp>, <samp>Ceiling</samp>, <samp>Roof</samp> or <samp>Room 1</samp>.
	Location string `json:"location,omitempty"`

	// The machines that are currently connected with the network.
	Machines []*MachinesItems `json:"machines,omitempty"`

	// This field is an additional field to give your sensor a name. This can be useful if you have multiple sensors in the same location.
	Name string `json:"name,omitempty"`

	// This field is optional but you can use it to the network type such as <samp>wifi</samp> or <samp>cable</samp>. You can even expose the number of <a href="https://spacefed.net/wiki/index.php/Spacenet" target="_blank">spacenet</a>-authenticated connections.
	Type string `json:"type,omitempty"`

	// The amount of network connections.
	Value float64 `json:"value"`
}

// NetworkTrafficItems
type NetworkTrafficItems struct {

	// An extra field that you can use to attach some additional information to this sensor instance
	Description string `json:"description,omitempty"`

	// Location the measurement relates to, e.g. <samp>WiFi</samp> or <samp>Uplink</samp>
	Location string `json:"location,omitempty"`

	// Name of the measurement, e.g. to distinguish between upstream and downstream traffic
	Name       string      `json:"name,omitempty"`
	Properties *Properties `json:"properties"`
}

// PacketsPerSecond
type PacketsPerSecond struct {

	// The measurement value, in packets/second
	Value float64 `json:"value"`
}

// PeopleNowPresentItems
type PeopleNowPresentItems struct {

	// An extra field that you can use to attach some additional information to this sensor instance.
	Description string `json:"description,omitempty"`

	// If you use multiple sensor instances for different rooms, use this field to indicate the location.
	Location string `json:"location,omitempty"`

	// Give this sensor a name if necessary at all. Use the location field for the rooms. This field is not intended to be used for names of hackerspace members. Use the field 'names' instead.
	Name string `json:"name,omitempty"`

	// List of hackerspace members that are currently occupying the space.
	Names []string `json:"names,omitempty"`

	// The amount of present people.
	Value float64 `json:"value"`
}

// PowerConsumptionItems
type PowerConsumptionItems struct {

	// An extra field that you can use to attach some additional information to this sensor instance.
	Description string `json:"description,omitempty"`

	// The location of your sensor such as <samp>Outside</samp>, <samp>Inside</samp>, <samp>Ceiling</samp>, <samp>Roof</samp> or <samp>Room 1</samp>.
	Location string `json:"location"`

	// This field is an additional field to give your sensor a name. This can be useful if you have multiple sensors in the same location.
	Name string `json:"name,omitempty"`

	// The unit of the sensor value. You should always define the unit though if the sensor is a flag of a boolean type then you can of course omit it.
	Unit string `json:"unit"`

	// The sensor value
	Value float64 `json:"value"`
}

// Properties
type Properties struct {

	// The wind direction in degrees.
	Direction *Direction `json:"direction"`

	// Height above mean sea level.
	Elevation *Elevation `json:"elevation"`
	Gust      *Gust      `json:"gust"`
	Speed     *Speed     `json:"speed"`
}

// Radiation Compound radiation sensor. Check this <a rel="nofollow" href="https://sites.google.com/site/diygeigercounter/gm-tubes-supported" target="_blank">resource</a>.
type Radiation struct {

	// An alpha sensor
	Alpha []*AlphaItems `json:"alpha,omitempty"`

	// A beta sensor
	Beta []*BetaItems `json:"beta,omitempty"`

	// A sensor which cannot filter beta and gamma radiation separately.
	BetaGamma []*BetaGammaItems `json:"beta_gamma,omitempty"`

	// A gamma sensor
	Gamma []*GammaItems `json:"gamma,omitempty"`
}

// Root SpaceAPI v15 (Draft)
type Root struct {

	// The versions your SpaceAPI endpoint supports
	ApiCompatibility []string `json:"api_compatibility"`

	// URL(s) of webcams in your space
	Cam []string `json:"cam,omitempty"`

	// Contact information about your space. You must define at least one which is in the list of allowed values of the issue_report_channels field.
	Contact *Contact `json:"contact"`

	// Events which happened recently in your space and which could be interesting to the public, like 'User X has entered/triggered/did something at timestamp Z'
	Events []*EventsItems `json:"events,omitempty"`

	// Feeds where users can get updates of your space
	Feeds *Feeds `json:"feeds,omitempty"`

	// Arbitrary links that you'd like to share
	Links []*LinksItems `json:"links,omitempty"`

	// Position data such as a postal address or geographic coordinates
	Location *Location `json:"location"`

	// URL to your space logo
	Logo string `json:"logo"`

	// A list of the different membership plans your hackerspace might have. Set the value according to your billing process. For example, if your membership fee is 10€ per month, but you bill it yearly (aka. the member pays the fee once per year), set the amount to 120 an the billing_interval to yearly.
	MembershipPlans []*MembershipPlansItems `json:"membership_plans,omitempty"`

	// Your project sites (links to GitHub, wikis or wherever your projects are hosted)
	Projects []string `json:"projects,omitempty"`

	// Data of various sensors in your space (e.g. temperature, humidity, amount of Club-Mate left, …). The only canonical property is the <em>temp</em> property, additional sensor types may be defined by you. In this case, you are requested to share your definition for inclusion in this specification.
	Sensors *Sensors `json:"sensors,omitempty"`

	// The name of your space
	Space string `json:"space"`

	// A flag indicating if the hackerspace uses SpaceFED, a federated login scheme so that visiting hackers can use the space WiFi with their home space credentials.
	Spacefed *Spacefed `json:"spacefed,omitempty"`

	// A collection of status-related data: actual open/closed status, icons, last change timestamp etc.
	State *State `json:"state,omitempty"`

	// URL to your space website
	Url string `json:"url"`
}

// Sensors Data of various sensors in your space (e.g. temperature, humidity, amount of Club-Mate left, …). The only canonical property is the <em>temp</em> property, additional sensor types may be defined by you. In this case, you are requested to share your definition for inclusion in this specification.
type Sensors struct {

	// How rich is your hackerspace?
	AccountBalance []*AccountBalanceItems `json:"account_balance,omitempty"`

	// Barometer sensor
	Barometer []*BarometerItems `json:"barometer,omitempty"`

	// How much Mate and beer is in your fridge?
	BeverageSupply []*BeverageSupplyItems `json:"beverage_supply,omitempty"`

	// Sensor type to indicate if a certain door is locked.
	DoorLocked []*DoorLockedItems `json:"door_locked,omitempty"`

	// Humidity sensor
	Humidity []*HumidityItems `json:"humidity,omitempty"`

	// This sensor type is to specify the currently active  ethernet or wireless network devices. You can create different instances for each network type.
	NetworkConnections []*NetworkConnectionsItems `json:"network_connections,omitempty"`

	// The current network traffic, in bits/second or packets/second (or both)
	NetworkTraffic []*NetworkTrafficItems `json:"network_traffic,omitempty"`

	// Specify the number of people that are currently in your space. Optionally you can define a list of names.
	PeopleNowPresent []*PeopleNowPresentItems `json:"people_now_present,omitempty"`

	// The power consumption of a specific device or of your whole space.
	PowerConsumption []*PowerConsumptionItems `json:"power_consumption,omitempty"`

	// Compound radiation sensor. Check this <a rel="nofollow" href="https://sites.google.com/site/diygeigercounter/gm-tubes-supported" target="_blank">resource</a>.
	Radiation *Radiation `json:"radiation,omitempty"`

	// Temperature sensor. To convert from one unit of temperature to another consider <a href="http://en.wikipedia.org/wiki/Temperature_conversion_formulas" target="_blank">Wikipedia</a>.
	Temperature []*TemperatureItems `json:"temperature,omitempty"`

	// Specify the number of space members.
	TotalMemberCount []*TotalMemberCountItems `json:"total_member_count,omitempty"`

	// Your wind sensor.
	Wind []*WindItems `json:"wind,omitempty"`
}

// Spacefed A flag indicating if the hackerspace uses SpaceFED, a federated login scheme so that visiting hackers can use the space WiFi with their home space credentials.
type Spacefed struct {

	// See the <a target="_blank" href="https://spacefed.net/index.php/Category:Howto/Spacenet">wiki</a>.
	Spacenet bool `json:"spacenet"`

	// See the <a target="_blank" href="https://spacefed.net/index.php?title=Spacesaml">wiki</a>.
	Spacesaml bool `json:"spacesaml"`
}

// Speed
type Speed struct {

	// The unit of the sensor value. You should always define the unit though if the sensor is a flag of a boolean type then you can of course omit it.
	Unit string `json:"unit"`

	// The sensor value
	Value float64 `json:"value"`
}

// State A collection of status-related data: actual open/closed status, icons, last change timestamp etc.
type State struct {

	// Icons that show the status graphically
	Icon *Icon `json:"icon,omitempty"`

	// The Unix timestamp when the space status changed most recently
	Lastchange float64 `json:"lastchange,omitempty"`

	// An additional free-form string, could be something like <samp>'open for public'</samp>, <samp>'members only'</samp> or whatever you want it to be
	Message string `json:"message,omitempty"`

	// A flag which indicates whether the space is currently open or closed. The state 'undefined' can be achieved by omitting this field. A missing 'open' property carries the semantics of a temporary unavailability of the state, whereas the absence of the 'state' property itself means the state is generally not implemented for this space.
	Open bool `json:"open,omitempty"`

	// The person who lastly changed the state e.g. opened or closed the space.
	TriggerPerson string `json:"trigger_person,omitempty"`
}

// TemperatureItems
type TemperatureItems struct {

	// An extra field that you can use to attach some additional information to this sensor instance.
	Description string `json:"description,omitempty"`

	// The location of your sensor such as <samp>Outside</samp>, <samp>Inside</samp>, <samp>Ceiling</samp>, <samp>Roof</samp> or <samp>Room 1</samp>.
	Location string `json:"location"`

	// This field is an additional field to give your sensor a name. This can be useful if you have multiple sensors in the same location.
	Name string `json:"name,omitempty"`

	// The unit of the sensor value.
	Unit string `json:"unit"`

	// The sensor value
	Value float64 `json:"value"`
}

// TotalMemberCountItems
type TotalMemberCountItems struct {

	// An extra field that you can use to attach some additional information to this sensor instance.
	Description string `json:"description,omitempty"`

	// Specify the location if your hackerspace has different departments (for whatever reason). This field is for one department. Every department should have its own sensor instance.
	Location string `json:"location,omitempty"`

	// You can use this field to specify if this sensor instance counts active or inactive members.
	Name string `json:"name,omitempty"`

	// The amount of your space members.
	Value float64 `json:"value"`
}

// Wiki
type Wiki struct {

	// Type of the feed, for example <samp>rss</samp>, <samp>atom</atom>, <samp>ical</samp>
	Type string `json:"type,omitempty"`

	// Feed URL
	Url string `json:"url"`
}

// WindItems
type WindItems struct {

	// An extra field that you can use to attach some additional information to this sensor instance.
	Description string `json:"description,omitempty"`

	// The location of your sensor such as <samp>Outside</samp>, <samp>Inside</samp>, <samp>Ceiling</samp>, <samp>Roof</samp> or <samp>Room 1</samp>.
	Location string `json:"location"`

	// This field is an additional field to give your sensor a name. This can be useful if you have multiple sensors in the same location.
	Name       string      `json:"name,omitempty"`
	Properties *Properties `json:"properties"`
}

func (strct *AccountBalanceItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "location" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"location\": ")
	if tmp, err := json.Marshal(strct.Location); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Unit" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "unit" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"unit\": ")
	if tmp, err := json.Marshal(strct.Unit); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Value" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "value" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AccountBalanceItems) UnmarshalJSON(b []byte) error {
	unitReceived := false
	valueReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "location":
			if err := json.Unmarshal([]byte(v), &strct.Location); err != nil {
				return err
			}
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		case "unit":
			if err := json.Unmarshal([]byte(v), &strct.Unit); err != nil {
				return err
			}
			unitReceived = true
		case "value":
			if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
			}
			valueReceived = true
		}
	}
	// check if unit (a required property) was received
	if !unitReceived {
		return errors.New("\"unit\" is required but was not present")
	}
	// check if value (a required property) was received
	if !valueReceived {
		return errors.New("\"value\" is required but was not present")
	}
	return nil
}

func (strct *AlphaItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "conversion_factor" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"conversion_factor\": ")
	if tmp, err := json.Marshal(strct.ConversionFactor); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "dead_time" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"dead_time\": ")
	if tmp, err := json.Marshal(strct.DeadTime); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "location" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"location\": ")
	if tmp, err := json.Marshal(strct.Location); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Unit" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "unit" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"unit\": ")
	if tmp, err := json.Marshal(strct.Unit); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Value" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "value" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *AlphaItems) UnmarshalJSON(b []byte) error {
	unitReceived := false
	valueReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "conversion_factor":
			if err := json.Unmarshal([]byte(v), &strct.ConversionFactor); err != nil {
				return err
			}
		case "dead_time":
			if err := json.Unmarshal([]byte(v), &strct.DeadTime); err != nil {
				return err
			}
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "location":
			if err := json.Unmarshal([]byte(v), &strct.Location); err != nil {
				return err
			}
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		case "unit":
			if err := json.Unmarshal([]byte(v), &strct.Unit); err != nil {
				return err
			}
			unitReceived = true
		case "value":
			if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
			}
			valueReceived = true
		}
	}
	// check if unit (a required property) was received
	if !unitReceived {
		return errors.New("\"unit\" is required but was not present")
	}
	// check if value (a required property) was received
	if !valueReceived {
		return errors.New("\"value\" is required but was not present")
	}
	return nil
}

func (strct *BarometerItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Location" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "location" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"location\": ")
	if tmp, err := json.Marshal(strct.Location); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Unit" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "unit" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"unit\": ")
	if tmp, err := json.Marshal(strct.Unit); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Value" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "value" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BarometerItems) UnmarshalJSON(b []byte) error {
	locationReceived := false
	unitReceived := false
	valueReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "location":
			if err := json.Unmarshal([]byte(v), &strct.Location); err != nil {
				return err
			}
			locationReceived = true
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		case "unit":
			if err := json.Unmarshal([]byte(v), &strct.Unit); err != nil {
				return err
			}
			unitReceived = true
		case "value":
			if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
			}
			valueReceived = true
		}
	}
	// check if location (a required property) was received
	if !locationReceived {
		return errors.New("\"location\" is required but was not present")
	}
	// check if unit (a required property) was received
	if !unitReceived {
		return errors.New("\"unit\" is required but was not present")
	}
	// check if value (a required property) was received
	if !valueReceived {
		return errors.New("\"value\" is required but was not present")
	}
	return nil
}

func (strct *BetaGammaItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "conversion_factor" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"conversion_factor\": ")
	if tmp, err := json.Marshal(strct.ConversionFactor); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "dead_time" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"dead_time\": ")
	if tmp, err := json.Marshal(strct.DeadTime); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "location" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"location\": ")
	if tmp, err := json.Marshal(strct.Location); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Unit" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "unit" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"unit\": ")
	if tmp, err := json.Marshal(strct.Unit); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Value" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "value" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BetaGammaItems) UnmarshalJSON(b []byte) error {
	unitReceived := false
	valueReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "conversion_factor":
			if err := json.Unmarshal([]byte(v), &strct.ConversionFactor); err != nil {
				return err
			}
		case "dead_time":
			if err := json.Unmarshal([]byte(v), &strct.DeadTime); err != nil {
				return err
			}
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "location":
			if err := json.Unmarshal([]byte(v), &strct.Location); err != nil {
				return err
			}
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		case "unit":
			if err := json.Unmarshal([]byte(v), &strct.Unit); err != nil {
				return err
			}
			unitReceived = true
		case "value":
			if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
			}
			valueReceived = true
		}
	}
	// check if unit (a required property) was received
	if !unitReceived {
		return errors.New("\"unit\" is required but was not present")
	}
	// check if value (a required property) was received
	if !valueReceived {
		return errors.New("\"value\" is required but was not present")
	}
	return nil
}

func (strct *BetaItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "conversion_factor" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"conversion_factor\": ")
	if tmp, err := json.Marshal(strct.ConversionFactor); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "dead_time" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"dead_time\": ")
	if tmp, err := json.Marshal(strct.DeadTime); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "location" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"location\": ")
	if tmp, err := json.Marshal(strct.Location); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Unit" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "unit" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"unit\": ")
	if tmp, err := json.Marshal(strct.Unit); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Value" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "value" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BetaItems) UnmarshalJSON(b []byte) error {
	unitReceived := false
	valueReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "conversion_factor":
			if err := json.Unmarshal([]byte(v), &strct.ConversionFactor); err != nil {
				return err
			}
		case "dead_time":
			if err := json.Unmarshal([]byte(v), &strct.DeadTime); err != nil {
				return err
			}
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "location":
			if err := json.Unmarshal([]byte(v), &strct.Location); err != nil {
				return err
			}
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		case "unit":
			if err := json.Unmarshal([]byte(v), &strct.Unit); err != nil {
				return err
			}
			unitReceived = true
		case "value":
			if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
			}
			valueReceived = true
		}
	}
	// check if unit (a required property) was received
	if !unitReceived {
		return errors.New("\"unit\" is required but was not present")
	}
	// check if value (a required property) was received
	if !valueReceived {
		return errors.New("\"value\" is required but was not present")
	}
	return nil
}

func (strct *BeverageSupplyItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "location" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"location\": ")
	if tmp, err := json.Marshal(strct.Location); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Unit" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "unit" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"unit\": ")
	if tmp, err := json.Marshal(strct.Unit); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Value" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "value" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BeverageSupplyItems) UnmarshalJSON(b []byte) error {
	unitReceived := false
	valueReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "location":
			if err := json.Unmarshal([]byte(v), &strct.Location); err != nil {
				return err
			}
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		case "unit":
			if err := json.Unmarshal([]byte(v), &strct.Unit); err != nil {
				return err
			}
			unitReceived = true
		case "value":
			if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
			}
			valueReceived = true
		}
	}
	// check if unit (a required property) was received
	if !unitReceived {
		return errors.New("\"unit\" is required but was not present")
	}
	// check if value (a required property) was received
	if !valueReceived {
		return errors.New("\"value\" is required but was not present")
	}
	return nil
}

func (strct *BitsPerSecond) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "maximum" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"maximum\": ")
	if tmp, err := json.Marshal(strct.Maximum); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Value" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "value" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *BitsPerSecond) UnmarshalJSON(b []byte) error {
	valueReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "maximum":
			if err := json.Unmarshal([]byte(v), &strct.Maximum); err != nil {
				return err
			}
		case "value":
			if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
			}
			valueReceived = true
		}
	}
	// check if value (a required property) was received
	if !valueReceived {
		return errors.New("\"value\" is required but was not present")
	}
	return nil
}

func (strct *Blog) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "type" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Url" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "url" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"url\": ")
	if tmp, err := json.Marshal(strct.Url); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Blog) UnmarshalJSON(b []byte) error {
	urlReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "type":
			if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
				return err
			}
		case "url":
			if err := json.Unmarshal([]byte(v), &strct.Url); err != nil {
				return err
			}
			urlReceived = true
		}
	}
	// check if url (a required property) was received
	if !urlReceived {
		return errors.New("\"url\" is required but was not present")
	}
	return nil
}

func (strct *Calendar) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "type" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Url" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "url" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"url\": ")
	if tmp, err := json.Marshal(strct.Url); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Calendar) UnmarshalJSON(b []byte) error {
	urlReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "type":
			if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
				return err
			}
		case "url":
			if err := json.Unmarshal([]byte(v), &strct.Url); err != nil {
				return err
			}
			urlReceived = true
		}
	}
	// check if url (a required property) was received
	if !urlReceived {
		return errors.New("\"url\" is required but was not present")
	}
	return nil
}

func (strct *Direction) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "Unit" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "unit" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"unit\": ")
	if tmp, err := json.Marshal(strct.Unit); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Value" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "value" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Direction) UnmarshalJSON(b []byte) error {
	unitReceived := false
	valueReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "unit":
			if err := json.Unmarshal([]byte(v), &strct.Unit); err != nil {
				return err
			}
			unitReceived = true
		case "value":
			if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
			}
			valueReceived = true
		}
	}
	// check if unit (a required property) was received
	if !unitReceived {
		return errors.New("\"unit\" is required but was not present")
	}
	// check if value (a required property) was received
	if !valueReceived {
		return errors.New("\"value\" is required but was not present")
	}
	return nil
}

func (strct *DoorLockedItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Location" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "location" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"location\": ")
	if tmp, err := json.Marshal(strct.Location); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Value" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "value" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *DoorLockedItems) UnmarshalJSON(b []byte) error {
	locationReceived := false
	valueReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "location":
			if err := json.Unmarshal([]byte(v), &strct.Location); err != nil {
				return err
			}
			locationReceived = true
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		case "value":
			if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
			}
			valueReceived = true
		}
	}
	// check if location (a required property) was received
	if !locationReceived {
		return errors.New("\"location\" is required but was not present")
	}
	// check if value (a required property) was received
	if !valueReceived {
		return errors.New("\"value\" is required but was not present")
	}
	return nil
}

func (strct *Elevation) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "Unit" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "unit" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"unit\": ")
	if tmp, err := json.Marshal(strct.Unit); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Value" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "value" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Elevation) UnmarshalJSON(b []byte) error {
	unitReceived := false
	valueReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "unit":
			if err := json.Unmarshal([]byte(v), &strct.Unit); err != nil {
				return err
			}
			unitReceived = true
		case "value":
			if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
			}
			valueReceived = true
		}
	}
	// check if unit (a required property) was received
	if !unitReceived {
		return errors.New("\"unit\" is required but was not present")
	}
	// check if value (a required property) was received
	if !valueReceived {
		return errors.New("\"value\" is required but was not present")
	}
	return nil
}

func (strct *EventsItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "extra" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"extra\": ")
	if tmp, err := json.Marshal(strct.Extra); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Name" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Timestamp" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "timestamp" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"timestamp\": ")
	if tmp, err := json.Marshal(strct.Timestamp); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Type" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "type" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *EventsItems) UnmarshalJSON(b []byte) error {
	nameReceived := false
	timestampReceived := false
	typeReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "extra":
			if err := json.Unmarshal([]byte(v), &strct.Extra); err != nil {
				return err
			}
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
			nameReceived = true
		case "timestamp":
			if err := json.Unmarshal([]byte(v), &strct.Timestamp); err != nil {
				return err
			}
			timestampReceived = true
		case "type":
			if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
				return err
			}
			typeReceived = true
		}
	}
	// check if name (a required property) was received
	if !nameReceived {
		return errors.New("\"name\" is required but was not present")
	}
	// check if timestamp (a required property) was received
	if !timestampReceived {
		return errors.New("\"timestamp\" is required but was not present")
	}
	// check if type (a required property) was received
	if !typeReceived {
		return errors.New("\"type\" is required but was not present")
	}
	return nil
}

func (strct *Flickr) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "type" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Url" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "url" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"url\": ")
	if tmp, err := json.Marshal(strct.Url); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Flickr) UnmarshalJSON(b []byte) error {
	urlReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "type":
			if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
				return err
			}
		case "url":
			if err := json.Unmarshal([]byte(v), &strct.Url); err != nil {
				return err
			}
			urlReceived = true
		}
	}
	// check if url (a required property) was received
	if !urlReceived {
		return errors.New("\"url\" is required but was not present")
	}
	return nil
}

func (strct *GammaItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "conversion_factor" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"conversion_factor\": ")
	if tmp, err := json.Marshal(strct.ConversionFactor); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "dead_time" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"dead_time\": ")
	if tmp, err := json.Marshal(strct.DeadTime); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "location" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"location\": ")
	if tmp, err := json.Marshal(strct.Location); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Unit" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "unit" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"unit\": ")
	if tmp, err := json.Marshal(strct.Unit); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Value" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "value" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *GammaItems) UnmarshalJSON(b []byte) error {
	unitReceived := false
	valueReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "conversion_factor":
			if err := json.Unmarshal([]byte(v), &strct.ConversionFactor); err != nil {
				return err
			}
		case "dead_time":
			if err := json.Unmarshal([]byte(v), &strct.DeadTime); err != nil {
				return err
			}
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "location":
			if err := json.Unmarshal([]byte(v), &strct.Location); err != nil {
				return err
			}
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		case "unit":
			if err := json.Unmarshal([]byte(v), &strct.Unit); err != nil {
				return err
			}
			unitReceived = true
		case "value":
			if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
			}
			valueReceived = true
		}
	}
	// check if unit (a required property) was received
	if !unitReceived {
		return errors.New("\"unit\" is required but was not present")
	}
	// check if value (a required property) was received
	if !valueReceived {
		return errors.New("\"value\" is required but was not present")
	}
	return nil
}

func (strct *Gust) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "Unit" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "unit" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"unit\": ")
	if tmp, err := json.Marshal(strct.Unit); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Value" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "value" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Gust) UnmarshalJSON(b []byte) error {
	unitReceived := false
	valueReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "unit":
			if err := json.Unmarshal([]byte(v), &strct.Unit); err != nil {
				return err
			}
			unitReceived = true
		case "value":
			if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
			}
			valueReceived = true
		}
	}
	// check if unit (a required property) was received
	if !unitReceived {
		return errors.New("\"unit\" is required but was not present")
	}
	// check if value (a required property) was received
	if !valueReceived {
		return errors.New("\"value\" is required but was not present")
	}
	return nil
}

func (strct *HumidityItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Location" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "location" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"location\": ")
	if tmp, err := json.Marshal(strct.Location); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Unit" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "unit" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"unit\": ")
	if tmp, err := json.Marshal(strct.Unit); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Value" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "value" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *HumidityItems) UnmarshalJSON(b []byte) error {
	locationReceived := false
	unitReceived := false
	valueReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "location":
			if err := json.Unmarshal([]byte(v), &strct.Location); err != nil {
				return err
			}
			locationReceived = true
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		case "unit":
			if err := json.Unmarshal([]byte(v), &strct.Unit); err != nil {
				return err
			}
			unitReceived = true
		case "value":
			if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
			}
			valueReceived = true
		}
	}
	// check if location (a required property) was received
	if !locationReceived {
		return errors.New("\"location\" is required but was not present")
	}
	// check if unit (a required property) was received
	if !unitReceived {
		return errors.New("\"unit\" is required but was not present")
	}
	// check if value (a required property) was received
	if !valueReceived {
		return errors.New("\"value\" is required but was not present")
	}
	return nil
}

func (strct *Icon) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "Closed" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "closed" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"closed\": ")
	if tmp, err := json.Marshal(strct.Closed); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Open" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "open" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"open\": ")
	if tmp, err := json.Marshal(strct.Open); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Icon) UnmarshalJSON(b []byte) error {
	closedReceived := false
	openReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "closed":
			if err := json.Unmarshal([]byte(v), &strct.Closed); err != nil {
				return err
			}
			closedReceived = true
		case "open":
			if err := json.Unmarshal([]byte(v), &strct.Open); err != nil {
				return err
			}
			openReceived = true
		}
	}
	// check if closed (a required property) was received
	if !closedReceived {
		return errors.New("\"closed\" is required but was not present")
	}
	// check if open (a required property) was received
	if !openReceived {
		return errors.New("\"open\" is required but was not present")
	}
	return nil
}

func (strct *LinksItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Name" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Url" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "url" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"url\": ")
	if tmp, err := json.Marshal(strct.Url); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *LinksItems) UnmarshalJSON(b []byte) error {
	nameReceived := false
	urlReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
			nameReceived = true
		case "url":
			if err := json.Unmarshal([]byte(v), &strct.Url); err != nil {
				return err
			}
			urlReceived = true
		}
	}
	// check if name (a required property) was received
	if !nameReceived {
		return errors.New("\"name\" is required but was not present")
	}
	// check if url (a required property) was received
	if !urlReceived {
		return errors.New("\"url\" is required but was not present")
	}
	return nil
}

func (strct *Location) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "address" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"address\": ")
	if tmp, err := json.Marshal(strct.Address); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Lat" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "lat" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"lat\": ")
	if tmp, err := json.Marshal(strct.Lat); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Lon" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "lon" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"lon\": ")
	if tmp, err := json.Marshal(strct.Lon); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "timezone" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"timezone\": ")
	if tmp, err := json.Marshal(strct.Timezone); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Location) UnmarshalJSON(b []byte) error {
	latReceived := false
	lonReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "address":
			if err := json.Unmarshal([]byte(v), &strct.Address); err != nil {
				return err
			}
		case "lat":
			if err := json.Unmarshal([]byte(v), &strct.Lat); err != nil {
				return err
			}
			latReceived = true
		case "lon":
			if err := json.Unmarshal([]byte(v), &strct.Lon); err != nil {
				return err
			}
			lonReceived = true
		case "timezone":
			if err := json.Unmarshal([]byte(v), &strct.Timezone); err != nil {
				return err
			}
		}
	}
	// check if lat (a required property) was received
	if !latReceived {
		return errors.New("\"lat\" is required but was not present")
	}
	// check if lon (a required property) was received
	if !lonReceived {
		return errors.New("\"lon\" is required but was not present")
	}
	return nil
}

func (strct *MachinesItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "Mac" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "mac" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"mac\": ")
	if tmp, err := json.Marshal(strct.Mac); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MachinesItems) UnmarshalJSON(b []byte) error {
	macReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "mac":
			if err := json.Unmarshal([]byte(v), &strct.Mac); err != nil {
				return err
			}
			macReceived = true
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		}
	}
	// check if mac (a required property) was received
	if !macReceived {
		return errors.New("\"mac\" is required but was not present")
	}
	return nil
}

func (strct *MembershipPlansItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "BillingInterval" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "billing_interval" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"billing_interval\": ")
	if tmp, err := json.Marshal(strct.BillingInterval); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Currency" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "currency" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"currency\": ")
	if tmp, err := json.Marshal(strct.Currency); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Name" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Value" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "value" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *MembershipPlansItems) UnmarshalJSON(b []byte) error {
	billing_intervalReceived := false
	currencyReceived := false
	nameReceived := false
	valueReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "billing_interval":
			if err := json.Unmarshal([]byte(v), &strct.BillingInterval); err != nil {
				return err
			}
			billing_intervalReceived = true
		case "currency":
			if err := json.Unmarshal([]byte(v), &strct.Currency); err != nil {
				return err
			}
			currencyReceived = true
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
			nameReceived = true
		case "value":
			if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
			}
			valueReceived = true
		}
	}
	// check if billing_interval (a required property) was received
	if !billing_intervalReceived {
		return errors.New("\"billing_interval\" is required but was not present")
	}
	// check if currency (a required property) was received
	if !currencyReceived {
		return errors.New("\"currency\" is required but was not present")
	}
	// check if name (a required property) was received
	if !nameReceived {
		return errors.New("\"name\" is required but was not present")
	}
	// check if value (a required property) was received
	if !valueReceived {
		return errors.New("\"value\" is required but was not present")
	}
	return nil
}

func (strct *NetworkConnectionsItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "location" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"location\": ")
	if tmp, err := json.Marshal(strct.Location); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "machines" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"machines\": ")
	if tmp, err := json.Marshal(strct.Machines); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "type" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Value" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "value" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *NetworkConnectionsItems) UnmarshalJSON(b []byte) error {
	valueReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "location":
			if err := json.Unmarshal([]byte(v), &strct.Location); err != nil {
				return err
			}
		case "machines":
			if err := json.Unmarshal([]byte(v), &strct.Machines); err != nil {
				return err
			}
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		case "type":
			if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
				return err
			}
		case "value":
			if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
			}
			valueReceived = true
		}
	}
	// check if value (a required property) was received
	if !valueReceived {
		return errors.New("\"value\" is required but was not present")
	}
	return nil
}

func (strct *NetworkTrafficItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "location" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"location\": ")
	if tmp, err := json.Marshal(strct.Location); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Properties" field is required
	if strct.Properties == nil {
		return nil, errors.New("properties is a required field")
	}
	// Marshal the "properties" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"properties\": ")
	if tmp, err := json.Marshal(strct.Properties); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *NetworkTrafficItems) UnmarshalJSON(b []byte) error {
	propertiesReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "location":
			if err := json.Unmarshal([]byte(v), &strct.Location); err != nil {
				return err
			}
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		case "properties":
			if err := json.Unmarshal([]byte(v), &strct.Properties); err != nil {
				return err
			}
			propertiesReceived = true
		}
	}
	// check if properties (a required property) was received
	if !propertiesReceived {
		return errors.New("\"properties\" is required but was not present")
	}
	return nil
}

func (strct *PacketsPerSecond) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "Value" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "value" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PacketsPerSecond) UnmarshalJSON(b []byte) error {
	valueReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "value":
			if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
			}
			valueReceived = true
		}
	}
	// check if value (a required property) was received
	if !valueReceived {
		return errors.New("\"value\" is required but was not present")
	}
	return nil
}

func (strct *PeopleNowPresentItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "location" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"location\": ")
	if tmp, err := json.Marshal(strct.Location); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "names" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"names\": ")
	if tmp, err := json.Marshal(strct.Names); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Value" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "value" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PeopleNowPresentItems) UnmarshalJSON(b []byte) error {
	valueReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "location":
			if err := json.Unmarshal([]byte(v), &strct.Location); err != nil {
				return err
			}
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		case "names":
			if err := json.Unmarshal([]byte(v), &strct.Names); err != nil {
				return err
			}
		case "value":
			if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
			}
			valueReceived = true
		}
	}
	// check if value (a required property) was received
	if !valueReceived {
		return errors.New("\"value\" is required but was not present")
	}
	return nil
}

func (strct *PowerConsumptionItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Location" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "location" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"location\": ")
	if tmp, err := json.Marshal(strct.Location); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Unit" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "unit" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"unit\": ")
	if tmp, err := json.Marshal(strct.Unit); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Value" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "value" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *PowerConsumptionItems) UnmarshalJSON(b []byte) error {
	locationReceived := false
	unitReceived := false
	valueReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "location":
			if err := json.Unmarshal([]byte(v), &strct.Location); err != nil {
				return err
			}
			locationReceived = true
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		case "unit":
			if err := json.Unmarshal([]byte(v), &strct.Unit); err != nil {
				return err
			}
			unitReceived = true
		case "value":
			if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
			}
			valueReceived = true
		}
	}
	// check if location (a required property) was received
	if !locationReceived {
		return errors.New("\"location\" is required but was not present")
	}
	// check if unit (a required property) was received
	if !unitReceived {
		return errors.New("\"unit\" is required but was not present")
	}
	// check if value (a required property) was received
	if !valueReceived {
		return errors.New("\"value\" is required but was not present")
	}
	return nil
}

func (strct *Properties) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "Direction" field is required
	if strct.Direction == nil {
		return nil, errors.New("direction is a required field")
	}
	// Marshal the "direction" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"direction\": ")
	if tmp, err := json.Marshal(strct.Direction); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Elevation" field is required
	if strct.Elevation == nil {
		return nil, errors.New("elevation is a required field")
	}
	// Marshal the "elevation" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"elevation\": ")
	if tmp, err := json.Marshal(strct.Elevation); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Gust" field is required
	if strct.Gust == nil {
		return nil, errors.New("gust is a required field")
	}
	// Marshal the "gust" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"gust\": ")
	if tmp, err := json.Marshal(strct.Gust); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Speed" field is required
	if strct.Speed == nil {
		return nil, errors.New("speed is a required field")
	}
	// Marshal the "speed" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"speed\": ")
	if tmp, err := json.Marshal(strct.Speed); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Properties) UnmarshalJSON(b []byte) error {
	directionReceived := false
	elevationReceived := false
	gustReceived := false
	speedReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "direction":
			if err := json.Unmarshal([]byte(v), &strct.Direction); err != nil {
				return err
			}
			directionReceived = true
		case "elevation":
			if err := json.Unmarshal([]byte(v), &strct.Elevation); err != nil {
				return err
			}
			elevationReceived = true
		case "gust":
			if err := json.Unmarshal([]byte(v), &strct.Gust); err != nil {
				return err
			}
			gustReceived = true
		case "speed":
			if err := json.Unmarshal([]byte(v), &strct.Speed); err != nil {
				return err
			}
			speedReceived = true
		}
	}
	// check if direction (a required property) was received
	if !directionReceived {
		return errors.New("\"direction\" is required but was not present")
	}
	// check if elevation (a required property) was received
	if !elevationReceived {
		return errors.New("\"elevation\" is required but was not present")
	}
	// check if gust (a required property) was received
	if !gustReceived {
		return errors.New("\"gust\" is required but was not present")
	}
	// check if speed (a required property) was received
	if !speedReceived {
		return errors.New("\"speed\" is required but was not present")
	}
	return nil
}

func (strct *Root) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "ApiCompatibility" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "api_compatibility" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"api_compatibility\": ")
	if tmp, err := json.Marshal(strct.ApiCompatibility); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "cam" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"cam\": ")
	if tmp, err := json.Marshal(strct.Cam); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Contact" field is required
	if strct.Contact == nil {
		return nil, errors.New("contact is a required field")
	}
	// Marshal the "contact" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"contact\": ")
	if tmp, err := json.Marshal(strct.Contact); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "events" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"events\": ")
	if tmp, err := json.Marshal(strct.Events); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "feeds" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"feeds\": ")
	if tmp, err := json.Marshal(strct.Feeds); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "links" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"links\": ")
	if tmp, err := json.Marshal(strct.Links); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Location" field is required
	if strct.Location == nil {
		return nil, errors.New("location is a required field")
	}
	// Marshal the "location" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"location\": ")
	if tmp, err := json.Marshal(strct.Location); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Logo" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "logo" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"logo\": ")
	if tmp, err := json.Marshal(strct.Logo); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "membership_plans" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"membership_plans\": ")
	if tmp, err := json.Marshal(strct.MembershipPlans); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "projects" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"projects\": ")
	if tmp, err := json.Marshal(strct.Projects); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "sensors" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"sensors\": ")
	if tmp, err := json.Marshal(strct.Sensors); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Space" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "space" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"space\": ")
	if tmp, err := json.Marshal(strct.Space); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "spacefed" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"spacefed\": ")
	if tmp, err := json.Marshal(strct.Spacefed); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "state" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"state\": ")
	if tmp, err := json.Marshal(strct.State); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Url" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "url" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"url\": ")
	if tmp, err := json.Marshal(strct.Url); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Root) UnmarshalJSON(b []byte) error {
	api_compatibilityReceived := false
	contactReceived := false
	locationReceived := false
	logoReceived := false
	spaceReceived := false
	urlReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "api_compatibility":
			if err := json.Unmarshal([]byte(v), &strct.ApiCompatibility); err != nil {
				return err
			}
			api_compatibilityReceived = true
		case "cam":
			if err := json.Unmarshal([]byte(v), &strct.Cam); err != nil {
				return err
			}
		case "contact":
			if err := json.Unmarshal([]byte(v), &strct.Contact); err != nil {
				return err
			}
			contactReceived = true
		case "events":
			if err := json.Unmarshal([]byte(v), &strct.Events); err != nil {
				return err
			}
		case "feeds":
			if err := json.Unmarshal([]byte(v), &strct.Feeds); err != nil {
				return err
			}
		case "links":
			if err := json.Unmarshal([]byte(v), &strct.Links); err != nil {
				return err
			}
		case "location":
			if err := json.Unmarshal([]byte(v), &strct.Location); err != nil {
				return err
			}
			locationReceived = true
		case "logo":
			if err := json.Unmarshal([]byte(v), &strct.Logo); err != nil {
				return err
			}
			logoReceived = true
		case "membership_plans":
			if err := json.Unmarshal([]byte(v), &strct.MembershipPlans); err != nil {
				return err
			}
		case "projects":
			if err := json.Unmarshal([]byte(v), &strct.Projects); err != nil {
				return err
			}
		case "sensors":
			if err := json.Unmarshal([]byte(v), &strct.Sensors); err != nil {
				return err
			}
		case "space":
			if err := json.Unmarshal([]byte(v), &strct.Space); err != nil {
				return err
			}
			spaceReceived = true
		case "spacefed":
			if err := json.Unmarshal([]byte(v), &strct.Spacefed); err != nil {
				return err
			}
		case "state":
			if err := json.Unmarshal([]byte(v), &strct.State); err != nil {
				return err
			}
		case "url":
			if err := json.Unmarshal([]byte(v), &strct.Url); err != nil {
				return err
			}
			urlReceived = true
		}
	}
	// check if api_compatibility (a required property) was received
	if !api_compatibilityReceived {
		return errors.New("\"api_compatibility\" is required but was not present")
	}
	// check if contact (a required property) was received
	if !contactReceived {
		return errors.New("\"contact\" is required but was not present")
	}
	// check if location (a required property) was received
	if !locationReceived {
		return errors.New("\"location\" is required but was not present")
	}
	// check if logo (a required property) was received
	if !logoReceived {
		return errors.New("\"logo\" is required but was not present")
	}
	// check if space (a required property) was received
	if !spaceReceived {
		return errors.New("\"space\" is required but was not present")
	}
	// check if url (a required property) was received
	if !urlReceived {
		return errors.New("\"url\" is required but was not present")
	}
	return nil
}

func (strct *Spacefed) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "Spacenet" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "spacenet" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"spacenet\": ")
	if tmp, err := json.Marshal(strct.Spacenet); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Spacesaml" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "spacesaml" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"spacesaml\": ")
	if tmp, err := json.Marshal(strct.Spacesaml); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Spacefed) UnmarshalJSON(b []byte) error {
	spacenetReceived := false
	spacesamlReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "spacenet":
			if err := json.Unmarshal([]byte(v), &strct.Spacenet); err != nil {
				return err
			}
			spacenetReceived = true
		case "spacesaml":
			if err := json.Unmarshal([]byte(v), &strct.Spacesaml); err != nil {
				return err
			}
			spacesamlReceived = true
		}
	}
	// check if spacenet (a required property) was received
	if !spacenetReceived {
		return errors.New("\"spacenet\" is required but was not present")
	}
	// check if spacesaml (a required property) was received
	if !spacesamlReceived {
		return errors.New("\"spacesaml\" is required but was not present")
	}
	return nil
}

func (strct *Speed) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// "Unit" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "unit" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"unit\": ")
	if tmp, err := json.Marshal(strct.Unit); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Value" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "value" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Speed) UnmarshalJSON(b []byte) error {
	unitReceived := false
	valueReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "unit":
			if err := json.Unmarshal([]byte(v), &strct.Unit); err != nil {
				return err
			}
			unitReceived = true
		case "value":
			if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
			}
			valueReceived = true
		}
	}
	// check if unit (a required property) was received
	if !unitReceived {
		return errors.New("\"unit\" is required but was not present")
	}
	// check if value (a required property) was received
	if !valueReceived {
		return errors.New("\"value\" is required but was not present")
	}
	return nil
}

func (strct *TemperatureItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Location" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "location" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"location\": ")
	if tmp, err := json.Marshal(strct.Location); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Unit" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "unit" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"unit\": ")
	if tmp, err := json.Marshal(strct.Unit); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Value" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "value" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TemperatureItems) UnmarshalJSON(b []byte) error {
	locationReceived := false
	unitReceived := false
	valueReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "location":
			if err := json.Unmarshal([]byte(v), &strct.Location); err != nil {
				return err
			}
			locationReceived = true
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		case "unit":
			if err := json.Unmarshal([]byte(v), &strct.Unit); err != nil {
				return err
			}
			unitReceived = true
		case "value":
			if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
			}
			valueReceived = true
		}
	}
	// check if location (a required property) was received
	if !locationReceived {
		return errors.New("\"location\" is required but was not present")
	}
	// check if unit (a required property) was received
	if !unitReceived {
		return errors.New("\"unit\" is required but was not present")
	}
	// check if value (a required property) was received
	if !valueReceived {
		return errors.New("\"value\" is required but was not present")
	}
	return nil
}

func (strct *TotalMemberCountItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "location" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"location\": ")
	if tmp, err := json.Marshal(strct.Location); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Value" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "value" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"value\": ")
	if tmp, err := json.Marshal(strct.Value); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *TotalMemberCountItems) UnmarshalJSON(b []byte) error {
	valueReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "location":
			if err := json.Unmarshal([]byte(v), &strct.Location); err != nil {
				return err
			}
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		case "value":
			if err := json.Unmarshal([]byte(v), &strct.Value); err != nil {
				return err
			}
			valueReceived = true
		}
	}
	// check if value (a required property) was received
	if !valueReceived {
		return errors.New("\"value\" is required but was not present")
	}
	return nil
}

func (strct *Wiki) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "type" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"type\": ")
	if tmp, err := json.Marshal(strct.Type); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Url" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "url" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"url\": ")
	if tmp, err := json.Marshal(strct.Url); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Wiki) UnmarshalJSON(b []byte) error {
	urlReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "type":
			if err := json.Unmarshal([]byte(v), &strct.Type); err != nil {
				return err
			}
		case "url":
			if err := json.Unmarshal([]byte(v), &strct.Url); err != nil {
				return err
			}
			urlReceived = true
		}
	}
	// check if url (a required property) was received
	if !urlReceived {
		return errors.New("\"url\" is required but was not present")
	}
	return nil
}

func (strct *WindItems) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
	comma := false
	// Marshal the "description" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"description\": ")
	if tmp, err := json.Marshal(strct.Description); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Location" field is required
	// only required object types supported for marshal checking (for now)
	// Marshal the "location" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"location\": ")
	if tmp, err := json.Marshal(strct.Location); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// Marshal the "name" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true
	// "Properties" field is required
	if strct.Properties == nil {
		return nil, errors.New("properties is a required field")
	}
	// Marshal the "properties" field
	if comma {
		buf.WriteString(",")
	}
	buf.WriteString("\"properties\": ")
	if tmp, err := json.Marshal(strct.Properties); err != nil {
		return nil, err
	} else {
		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *WindItems) UnmarshalJSON(b []byte) error {
	locationReceived := false
	propertiesReceived := false
	var jsonMap map[string]json.RawMessage
	if err := json.Unmarshal(b, &jsonMap); err != nil {
		return err
	}
	// parse all the defined properties
	for k, v := range jsonMap {
		switch k {
		case "description":
			if err := json.Unmarshal([]byte(v), &strct.Description); err != nil {
				return err
			}
		case "location":
			if err := json.Unmarshal([]byte(v), &strct.Location); err != nil {
				return err
			}
			locationReceived = true
		case "name":
			if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
				return err
			}
		case "properties":
			if err := json.Unmarshal([]byte(v), &strct.Properties); err != nil {
				return err
			}
			propertiesReceived = true
		}
	}
	// check if location (a required property) was received
	if !locationReceived {
		return errors.New("\"location\" is required but was not present")
	}
	// check if properties (a required property) was received
	if !propertiesReceived {
		return errors.New("\"properties\" is required but was not present")
	}
	return nil
}
